"""Lorentz dispersion helpers (closer to VBIDB FORTRAN parity).

Matches CEPSLNG.FOR and CEPSLN2.FOR:
  single: deps / (1 - x*(x - j*gamma)), x = f/fres
  double: sum of two such terms, plus epsv - j*sige/(f*A0)
Frequencies are in GHz.
"""

from __future__ import annotations

import numpy as np

A0 = 5.563249e-2  # 2*pi*eps0*1e9 (GHz scaling)


def _safe_freq(f_ghz: np.ndarray) -> np.ndarray:
    return np.maximum(f_ghz, 1e-6)


def single_lorentz(
    f_ghz: np.ndarray, fres: float, deps: float, epsv: float, gamma: float, sige: float = 0.0
) -> np.ndarray:
    f = _safe_freq(f_ghz)
    x = f / max(fres, 1e-12)
    g2 = gamma * gamma
    u = 1.0 / ((1.0 - x * x) ** 2 + x * x * g2)
    er = epsv + deps * (1.0 - x * x) * u
    ei = -deps * gamma * x * u - sige / (f * A0)
    return er + 1j * ei


def double_lorentz(
    f_ghz: np.ndarray,
    fres1: float,
    deps1: float,
    gamma1: float,
    fres2: float,
    deps2: float,
    gamma2: float,
    epsv: float,
    sige: float = 0.0,
) -> np.ndarray:
    f = _safe_freq(f_ghz)
    cond_term = -1j * sige / (f * A0)

    def _comp(fres: float, deps: float, gamma: float) -> np.ndarray:
        x = f / max(fres, 1e-12)
        return deps / (1.0 - x * (x - 1j * gamma))

    c1 = _comp(fres1, deps1, gamma1)
    c2 = _comp(fres2, deps2, gamma2)
    return epsv + cond_term + c1 + c2


__all__ = [
    "single_lorentz",
    "double_lorentz",
]
